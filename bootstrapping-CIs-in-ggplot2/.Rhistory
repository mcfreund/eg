p[ii, c("het.param", "hom.param")] <- c(cor.test(x, het)$p.value, cor.test(x, hom)$p.value)
# p[ii, c("het.boot", "hom.boot")] <- c(
#   boot.bivar(x, het)["p"],
#   boot.bivar(x, hom)["p"]
# )
}
par(mfrow = c(1, 2), mar = c(2, 2, 2, 2))
plot(x, het, main = "x ~ het")
plot(x, hom, main = "x ~ hom")
cor(x, het)
cor(x, hom)
colMeans(apply(p, 2, function(x) x < 0.05)) * 100  ## false positive rate for each statistic
par(mfrow = c(2, 2), mar = c(2, 2, 2, 2))
hist(p$het.param, main = "heteroskedastic, parametric")
hist(p$hom.param, main = "homoskedastic, parametric")
hist(p$het.boot, main = "heteroskedastic, bootstrapped")
hist(p$hom.boot, main = "homoskedastic, bootstrapped")
n <- 100  ## n datapoints
n.sims <- 5000
x <- 1:n  ## values from some measure
p <- data.frame(
het.param = vector("numeric", length = n.sims),
hom.param = vector("numeric", length = n.sims),
het.boot  = vector("numeric", length = n.sims),
hom.boot  = vector("numeric", length = n.sims)
)
for (ii in seq_len(n.sims)) {
het <- rnorm(n, sd = mean(x)) ## generate variable that is heteroskedastic and uncorrelated with x
hom <- rnorm(n, sd = mean(x))  ## generate variable z which is homoskedastic and uncorrelated with x
p[ii, c("het.param", "hom.param")] <- c(cor.test(x, het)$p.value, cor.test(x, hom)$p.value)
# p[ii, c("het.boot", "hom.boot")] <- c(
#   boot.bivar(x, het)["p"],
#   boot.bivar(x, hom)["p"]
# )
}
par(mfrow = c(1, 2), mar = c(2, 2, 2, 2))
plot(x, het, main = "x ~ het")
plot(x, hom, main = "x ~ hom")
cor(x, het)
cor(x, hom)
colMeans(apply(p, 2, function(x) x < 0.05)) * 100  ## false positive rate for each statistic
par(mfrow = c(2, 2), mar = c(2, 2, 2, 2))
hist(p$het.param, main = "heteroskedastic, parametric")
hist(p$hom.param, main = "homoskedastic, parametric")
hist(p$het.boot, main = "heteroskedastic, bootstrapped")
hist(p$hom.boot, main = "homoskedastic, bootstrapped")
n <- 100  ## n datapoints
n.sims <- 10000
x <- 1:n  ## values from some measure
p <- data.frame(
het.param = vector("numeric", length = n.sims),
hom.param = vector("numeric", length = n.sims),
het.boot  = vector("numeric", length = n.sims),
hom.boot  = vector("numeric", length = n.sims)
)
for (ii in seq_len(n.sims)) {
het <- rnorm(n, sd = mean(x)) ## generate variable that is heteroskedastic and uncorrelated with x
hom <- rnorm(n, sd = mean(x))  ## generate variable z which is homoskedastic and uncorrelated with x
p[ii, c("het.param", "hom.param")] <- c(cor.test(x, het)$p.value, cor.test(x, hom)$p.value)
# p[ii, c("het.boot", "hom.boot")] <- c(
#   boot.bivar(x, het)["p"],
#   boot.bivar(x, hom)["p"]
# )
}
par(mfrow = c(1, 2), mar = c(2, 2, 2, 2))
plot(x, het, main = "x ~ het")
plot(x, hom, main = "x ~ hom")
cor(x, het)
cor(x, hom)
colMeans(apply(p, 2, function(x) x < 0.05)) * 100  ## false positive rate for each statistic
par(mfrow = c(2, 2), mar = c(2, 2, 2, 2))
hist(p$het.param, main = "heteroskedastic, parametric")
hist(p$hom.param, main = "homoskedastic, parametric")
hist(p$het.boot, main = "heteroskedastic, bootstrapped")
hist(p$hom.boot, main = "homoskedastic, bootstrapped")
n <- 100  ## n datapoints
n.sims <- 10000
x <- 1:n  ## values from some measure
p <- data.frame(
het.param = vector("numeric", length = n.sims),
hom.param = vector("numeric", length = n.sims),
het.boot  = vector("numeric", length = n.sims),
hom.boot  = vector("numeric", length = n.sims)
)
for (ii in seq_len(n.sims)) {
het <- rnorm(n, sd = mean(x)) ## generate variable that is heteroskedastic and uncorrelated with x
hom <- rnorm(n, sd = mean(x))  ## generate variable z which is homoskedastic and uncorrelated with x
p[ii, c("het.param", "hom.param")] <- c(cor.test(x, het)$p.value, cor.test(x, hom)$p.value)
p[ii, c("het.boot", "hom.boot")] <- c(
boot.bivar(x, het, n.resamples = 100)["p"],
boot.bivar(x, hom, n.resamples = 100)["p"]
)
}
par(mfrow = c(1, 2), mar = c(2, 2, 2, 2))
plot(x, het, main = "x ~ het")
plot(x, hom, main = "x ~ hom")
cor(x, het)
cor(x, hom)
colMeans(apply(p, 2, function(x) x < 0.05)) * 100  ## false positive rate for each statistic
par(mfrow = c(2, 2), mar = c(2, 2, 2, 2))
hist(p$het.param, main = "heteroskedastic, parametric")
hist(p$hom.param, main = "homoskedastic, parametric")
hist(p$het.boot, main = "heteroskedastic, bootstrapped")
hist(p$hom.boot, main = "homoskedastic, bootstrapped")
p
library(foreach)
library(doParallel)
install.packages("doParallel")
library(doParallel)
x <- iris[which(iris[,5] != "setosa"), c(1,5)]
trials <- 10000
icount
icount(trials)
r <- foreach(icount(trials), .combine=cbind) %dopar% {
ind <- sample(100, 100, replace=TRUE)
result1 <- glm(x[ind,2]~x[ind,1], family=binomial(logit))
coefficients(result1)
}
source('~/.active-rstudio-document', echo=TRUE)
knitr::opts_chunk$set(echo = TRUE, fig.align = 'center', fig.width = 3, fig.height = 3)
library(ggplot2)
set.seed(0)
n <- 100  ## n datapoints
x <- 1:n  ## some measure x
y <- rnorm(x, x, sd = x)  ## some measure y; mean and variance depends on x
p <- ggplot(data.frame(x, y), aes(x, y)) +
geom_point(fill = "black", color = "white", shape = 21, size = 3) +
theme(
axis.ticks = element_blank(),
axis.text  = element_blank(),
axis.line  = element_blank(),
panel.background = element_blank()
)
p
boot.bivar <- function(x, y, n.resamples = 1000) {
if (length(x) != length(y)) stop("x and y not same length")
resample.matrix <- matrix(
sample.int(length(x), length(x) * n.resamples, replace = TRUE),
ncol = n.resamples
)
resamples <- apply(resample.matrix, 2, function(s) cor(x[s], y[s]))
## get p-value (alpha = 0.05, 2-tailed):
prop.less.0 <- mean(resamples < 0)
p <- 2 * min(prop.less.0, 1 - prop.less.0)
## get CI (95%):
lb <- (1 / 20 * n.resamples) / 2
ub <- n.resamples - lb
resamples <- sort(resamples)
return(c(p = p, ci95l = resamples[lb], ci95h = resamples[ub]))
}
boot.bivar(x, y)
p + geom_smooth(method = "lm")
# function for getting confidence interval:
boot.bivar.predict <- function(
.data, xname, yname, n.resamples = 1000, percent = 95) {
.formula <- paste0(yname, " ~ ", xname)
predictions <- sapply(
seq_len(n.resamples),
function(.)
predict(
lm(.formula, .data[sample.int(nrow(.data), replace = TRUE), ]),
.data[xname],
)
)
.alpha <- (100 - percent) / 100  ## convert to alpha level
data.frame(
ub = apply(predictions, 1, quantile, 1 - .alpha / 2),  ## 2-tailed
lb = apply(predictions, 1, quantile, 0 + .alpha / 2)
)
}
xy.ci <- boot.bivar.predict(data.frame(x, y), "x", "y")  ## get prediction interval
p + geom_ribbon(ymin = xy.ci$lb, ymax = xy.ci$ub, alpha = 0.3)  ## add to plot
xy.ci
p
p + geom_ribbon(ymin = xy.ci$lb, ymax = xy.ci$ub, alpha = 0.3)  ## add to plot
library(ggplot2)
p + geom_ribbon(aes(ymin = xy.ci$lb, ymax = xy.ci$ub), alpha = 0.3)  ## add to plot
p + geom_ribbon(ymin = xy.ci$lb, ymax = xy.ci$ub, alpha = 0.3)  ## add to plot
xy.ci$ub
xy.ci$lb
p + geom_ribbon(aes(ymin = xy.ci$lb, ymax = xy.ci$ub), alpha = 0.3)  ## add to plot
## embed function within ggplot framework:
BootCI <- ggproto(
"BootCI", Stat,
required_aes = c("x", "y"),
compute_group = function(data, scales, params, n = 1000, percent = 95) {
grid <- data.frame(x = data$x)
predictions <- sapply(
seq_len(n),
function(.)
predict(
lm(y ~ x, data[sample.int(nrow(data), replace = TRUE), ]),
grid,
)
)
.alpha <- (100 - percent) / 200  ## 2 tailed
grid$ymax <- apply(predictions, 1, quantile, 1 - .alpha)
grid$ymin <- apply(predictions, 1, quantile, .alpha)
grid
}
)
stat_boot_ci <- function(mapping = NULL, data = NULL, geom = "ribbon",
position = "identity", na.rm = FALSE, show.legend = NA,
inherit.aes = TRUE, n = 1000, percent = 95, ...) {
## see: https://cran.r-project.org/web/packages/ggplot2/vignettes/extending-ggplot2.html
layer(
stat = BootCI, data = data, mapping = mapping, geom = geom,
position = position, show.legend = show.legend, inherit.aes = inherit.aes,
params = list(n = n, percent = percent, na.rm = na.rm, ...)
)
}
p +
geom_smooth(method = "lm", se = TRUE, fill = "red", alpha = 1) +
stat_boot_ci(alpha = 0.3, n = 1E4, percent = 95)
n.sims <- 1000
p <- data.frame(
het.param = vector("numeric", length = n.sims),
hom.param = vector("numeric", length = n.sims),
het.boot  = vector("numeric", length = n.sims),
hom.boot  = vector("numeric", length = n.sims)
)
for (ii in seq_len(n.sims)) {
het <- rnorm(n, sd = x) ## generate variable that is heteroskedastic and uncorrelated with x
hom <- rnorm(n, sd = mean(x))  ## generate variable z which is homoskedastic and uncorrelated with x
p[ii, c("het.param", "hom.param")] <- c(cor.test(x, het)$p.value, cor.test(x, hom)$p.value)
p[ii, c("het.boot", "hom.boot")] <- c(boot.bivar(x, het)["p"], boot.bivar(x, hom)["p"])
}
par(mfrow = c(1, 2), mar = c(2, 2, 2, 2))
plot(x, het, main = "x ~ het")
plot(x, hom, main = "x ~ hom")
cor(x, het)
cor(x, hom)
colMeans(apply(p, 2, function(x) x < 0.05)) * 100  ## false positive rate for each statistic
par(mfrow = c(2, 2), mar = c(2, 2, 2, 2))
hist(p$het.param, main = "heteroskedastic, parametric")
hist(p$hom.param, main = "homoskedastic, parametric")
hist(p$het.boot, main = "heteroskedastic, bootstrapped")
hist(p$hom.boot, main = "homoskedastic, bootstrapped")
?lowess
p$het.param
lowess(p$het.param)
lowess(p$het.param, iter = 10)
plot(lowess(p$het.param))
lowess(p$het.param)
lowess(p$het.param) -> a
a
class(a)
plot(density(p$het.param))
density(p$het.param)
density?
?density
plot(density(p$het.param, from = 0, to = 1))
colMeans(apply(p, 2, function(x) x < 0.05)) * 100  ## false positive rate for each statistic
par(mfrow = c(2, 2), mar = c(2, 2, 2, 2))
plot(density(p$het.param, from = 0, to = 1))
plot(density(p$hom.param, from = 0, to = 1))
plot(density(p$het.boot, from = 0, to = 1))
plot(density(p$hom.boot, from = 0, to = 1))
?binom.test
binom.test(sum(p$het.param < 0.05), n = n.sims, alternative = "less")
binom.test(sum(p$hom.param < 0.05), n = n.sims, alternative = "less")
binom.test(sum(p$het.param < 0.05), n = n.sims, p = 0.05, alternative = "less")
binom.test(sum(p$het.param < 0.05), n = n.sims, p = 0.05, alternative = "less")
binom.test(sum(p$het.param < 0.05), n = n.sims, p = 0.05, alternative = "less")$p
binom.test(sum(p$het.param < 0.05), n = n.sims, p = 0.05, alternative = "less")$p.value
binom.test(sum(p$hom.param < 0.05), n = n.sims, p = 0.05, alternative = "less")$p.value
binom.test(sum(p$het.boot < 0.05), n = n.sims, p = 0.05, alternative = "less")$p.value
binom.test(sum(p$het.param < 0.05), n = n.sims, p > 0.05, alternative = "less")$p.value
colMeans(apply(p, 2, function(x) x < 0.05)) * 100  ## false positive rate for each statistic
par(mfrow = c(2, 2), mar = c(2, 2, 2, 2))
plot(density(p$het.param, from = 0, to = 1))
plot(density(p$hom.param, from = 0, to = 1))
plot(density(p$het.boot, from = 0, to = 1))
plot(density(p$hom.boot, from = 0, to = 1))
plot.new()
plot(density(p$het.param, from = 0, to = 1))
plot(density(p$hom.param, from = 0, to = 1))
plot(density(p$het.boot, from = 0, to = 1))
plot(density(p$hom.boot, from = 0, to = 1))
plot.new()
plot.new()
plot(density(p$het.param, from = 0, to = 1))
plot(density(p$hom.param, from = 0, to = 1))
plot(density(p$het.boot, from = 0, to = 1))
plot(density(p$hom.boot, from = 0, to = 1))
plot(density(p$het.param, from = 0, to = 1))
abline(density(p$hom.param, from = 0, to = 1))
plot(density(p$het.param, from = 0, to = 1))
plot(density(p$hom.param, from = 0, to = 1), add = TRUE)
plot(density(p$het.boot, from = 0, to = 1), add = TRUE)
plot(density(p$hom.boot, from = 0, to = 1), add = TRUE)
matplot(density(p$het.param, from = 0, to = 1),
density(p$hom.param, from = 0, to = 1),type="l",col=c("blue","red"))
density(p$het.param, from = 0, to = 1)
plot(density(p$het.param, from = 0, to = 1))
lines(density(p$hom.param, from = 0, to = 1), add = TRUE)
plot(density(p$het.param, from = 0, to = 1))
lines(density(p$hom.param, from = 0, to = 1))
lines(density(p$het.boot, from = 0, to = 1))
plot(density(p$het.param, from = 0, to = 1))
lines(density(p$hom.param, from = 0, to = 1))
lines(density(p$het.boot, from = 0, to = 1))
plot(density(p$hom.boot, from = 0, to = 1))
plot.new()
plot(density(p$het.param, from = 0, to = 1))
lines(density(p$hom.param, from = 0, to = 1))
lines(density(p$het.boot, from = 0, to = 1))
lines(density(p$hom.boot, from = 0, to = 1))
lines
plot(density(p$het.param, from = 0, to = 1), col = "firebrick")
lines(density(p$hom.param, from = 0, to = 1), type = "dashed")
lines(density(p$hom.param, from = 0, to = 1), type = "-")
lines(density(p$hom.param, from = 0, to = 1), ltype = "dash")
lines(density(p$hom.param, from = 0, to = 1), linetype = "dashed")
lines(density(p$hom.param, from = 0, to = 1), lty = "dashed")
lines(density(p$hom.param, from = 0, to = 1), lty = 2)
lines(density(p$hom.param, from = 0, to = 1), lty = 2)
lines(density(p$hom.param, from = 0, to = 1), lty = 2)
lines(density(p$hom.param, from = 0, to = 1), lty = 2)
plot(density(p$het.param, from = 0, to = 1), col = "firebrick")
plot(density(p$het.param, from = 0, to = 1), col = "firebrick")
lines(density(p$hom.param, from = 0, to = 1), lty = 2)
plot(density(p$het.param, from = 0, to = 1))
lines(density(p$hom.param, from = 0, to = 1), lty = 2)
lines(density(p$het.boot, from = 0, to = 1), col = "firebrick")
lines(density(p$hom.boot, from = 0, to = 1), lty = 2, col = "firebrick")
plot(density(p$het.param, from = 0, to = 1), lwt = 1)
plot(density(p$het.param, from = 0, to = 1), lwd = 1)
plot(density(p$het.param, from = 0, to = 1), lwd = 2)
plot(density(p$het.param, from = 0, to = 1), lwd = 2)
lines(density(p$hom.param, from = 0, to = 1), lwd = 2, lty = 2)
lines(density(p$het.boot, from = 0, to = 1), lwd = 2, col = "firebrick")
lines(density(p$hom.boot, from = 0, to = 1), lwd = 2, lty = 2, col = "firebrick")
abline
abline(h = 0, v = 0.05)
set.seed(10)
n.sims <- 1000
p <- data.frame(
het.param = vector("numeric", length = n.sims),
hom.param = vector("numeric", length = n.sims),
het.boot  = vector("numeric", length = n.sims),
hom.boot  = vector("numeric", length = n.sims)
)
for (ii in seq_len(n.sims)) {
het <- rnorm(n, sd = x) ## generate variable that is heteroskedastic and uncorrelated with x
hom <- rnorm(n, sd = mean(x))  ## generate variable z which is homoskedastic and uncorrelated with x
p[ii, c("het.param", "hom.param")] <- c(cor.test(x, het)$p.value, cor.test(x, hom)$p.value)
p[ii, c("het.boot", "hom.boot")] <- c(boot.bivar(x, het)["p"], boot.bivar(x, hom)["p"])
}
par(mfrow = c(1, 2), mar = c(2, 2, 2, 2))
plot(x, het, main = "x ~ het")
plot(x, hom, main = "x ~ hom")
cor(x, het)
cor(x, hom)
colMeans(apply(p, 2, function(x) x < 0.05)) * 100  ## false positive rate for each statistic
par(mfrow = c(2, 2), mar = c(2, 2, 2, 2))
hist(p$het.param, main = "heteroskedastic, parametric")
hist(p$hom.param, main = "homoskedastic, parametric")
hist(p$het.boot, main = "heteroskedastic, bootstrapped")
hist(p$hom.boot, main = "homoskedastic, bootstrapped")
plot(density(p$het.param, from = 0, to = 1), lwd = 2, "p-value distribution")
lines(density(p$hom.param, from = 0, to = 1), lwd = 2, lty = 2)
lines(density(p$het.boot, from = 0, to = 1), lwd = 2, col = "firebrick")
lines(density(p$hom.boot, from = 0, to = 1), lwd = 2, lty = 2, col = "firebrick")
abline(h = 0, v = 0.05, col = "grey50")
plot(density(p$het.param, from = 0, to = 1), lwd = 2, "p-value distribution")
lines(density(p$hom.param, from = 0, to = 1), lwd = 2, lty = 2)
lines(density(p$het.boot, from = 0, to = 1), lwd = 2, col = "firebrick")
lines(density(p$hom.boot, from = 0, to = 1), lwd = 2, lty = 2, col = "firebrick")
abline(h = 0, v = 0.05, col = "grey50")
p$het.param
sum(p$het.param > 0.05)
c(sum(p$het.param > 0.05), sum(p$het.param < 0.05))
binom.test(
c(sum(p$het.param > 0.05), sum(p$het.param < 0.05)),
alternative = "greater"
)
binom.test(
c(sum(p$het.param < 0.05), sum(p$het.param < 0.05)),
alternative = "greater"
)
binom.test(
c(sum(p$hom.param < 0.05), sum(p$hom.param < 0.05)),
alternative = "greater"
)
binom.test(
c(sum(p$hom.param < 0.05), sum(p$hom.param < 0.05)),
alternative = "greater",
p = 0.05
)
binom.test(
c(sum(p$het.param < 0.05), sum(p$het.param < 0.05)),
alternative = "greater",
p = 0.05
)$p.value
binom.test(
c(sum(p$hom.param < 0.05), sum(p$hom.param < 0.05)),
alternative = "greater",
p = 0.05
)$p.value
binom.test(
c(sum(p$het.param < 0.05), sum(p$het.param > 0.05)),
alternative = "greater",
p = 0.05
)$p.value
binom.test(
c(sum(p$het.param < 0.05), sum(p$het.param > 0.05)),
alternative = "greater",
p = 0.05
)
binom.test(
sum(p$het.param < 0.05),
n = length(p$het.param),
alternative = "greater",
p = 0.05
)
binom.test(sum(p$het.param < alph), n = length(p$het.param), alternative = "greater", p = alph)
alph <- 0.05
binom.test(sum(p$het.param < alph), n = length(p$het.param), alternative = "greater", p = alph)
binom.test(sum(p$het.param < alph), n = n.sims, alternative = "greater", p = alph)
binom.test(sum(p$hom.param < alph), n = n.sims, alternative = "greater", p = alph)
binom.test(sum(p$het.param < alph), n = n.sims, alternative = "greater", p = alph)
binom.test(sum(p$hom.param < alph), n = n.sims, alternative = "greater", p = alph)
binom.test(sum(p$het.boot < alph), n = n.sims, alternative = "greater", p = alph)
binom.test(sum(p$hom.boot < alph), n = n.sims, alternative = "greater", p = alph)
sum(p$hom.boot < alph)
sum(p$het.boot < alph)
sum(p$hom.param < alph)
sum(p$het.param < alph)
boot.bivar
set.seed(1084)
n.sims <- 1000
p <- data.frame(
het.param = vector("numeric", length = n.sims),
hom.param = vector("numeric", length = n.sims),
het.boot  = vector("numeric", length = n.sims),
hom.boot  = vector("numeric", length = n.sims)
)
for (ii in seq_len(n.sims)) {
het <- rnorm(n, sd = x) ## generate variable that is heteroskedastic and uncorrelated with x
hom <- rnorm(n, sd = mean(x))  ## generate variable z which is homoskedastic and uncorrelated with x
p[ii, c("het.param", "hom.param")] <- c(cor.test(x, het)$p.value, cor.test(x, hom)$p.value)
p[ii, c("het.boot", "hom.boot")] <- c(boot.bivar(x, het)["p"], boot.bivar(x, hom)["p"])
}
par(mfrow = c(1, 2), mar = c(2, 2, 2, 2))
plot(x, het, main = "x ~ het")
plot(x, hom, main = "x ~ hom")
cor(x, het)
cor(x, hom)
colMeans(apply(p, 2, function(x) x < 0.05)) * 100  ## false positive rate for each statistic
par(mfrow = c(2, 2), mar = c(2, 2, 2, 2))
hist(p$het.param, main = "heteroskedastic, parametric")
hist(p$hom.param, main = "homoskedastic, parametric")
hist(p$het.boot, main = "heteroskedastic, bootstrapped")
hist(p$hom.boot, main = "homoskedastic, bootstrapped")
plot(density(p$het.param, from = 0, to = 1), lwd = 2, "p-value distribution")
lines(density(p$hom.param, from = 0, to = 1), lwd = 2, lty = 2)
lines(density(p$het.boot, from = 0, to = 1), lwd = 2, col = "firebrick")
lines(density(p$hom.boot, from = 0, to = 1), lwd = 2, lty = 2, col = "firebrick")
abline(h = 0, v = 0.05, col = "grey50")
plot(density(p$het.param, from = 0, to = 1), lwd = 2, "p-value distribution")
lines(density(p$hom.param, from = 0, to = 1), lwd = 2, lty = 2)
lines(density(p$het.boot, from = 0, to = 1), lwd = 2, col = "firebrick")
lines(density(p$hom.boot, from = 0, to = 1), lwd = 2, lty = 2, col = "firebrick")
abline(h = 0, v = 0.05, col = "grey50")
alph <- 0.05
binom.test(sum(p$het.param < alph), n = n.sims, alternative = "greater", p = alph)
binom.test(sum(p$hom.param < alph), n = n.sims, alternative = "greater", p = alph)
binom.test(sum(p$het.boot < alph), n = n.sims, alternative = "greater", p = alph)
binom.test(sum(p$hom.boot < alph), n = n.sims, alternative = "greater", p = alph)
het
hom
library(microbenchmark)
set.seed(2017)
n <- 1000
x <- rnorm(n)
X <- cbind(rep(1, length(x)), x)  ## add intercept
y <- rnorm(n)
check_for_equal_coefs <- function(values) {
tol <- 1e-12
max_error <- max(
c(
abs(values[[1]] - values[[2]]),
abs(values[[2]] - values[[3]]),
abs(values[[1]] - values[[3]]),
abs(values[[1]] - values[[4]]),
abs(values[[1]] - values[[5]])
)
)
max_error < tol
}
mbm <- microbenchmark(
"lm" = {
y.hat <- predict(lm(y ~ x))
},
"cor" = {
b1 <- cor(x, y) * sd(y) / sd(x)
b0 <- mean(y) - b1 * mean(x)
y.hat <- b1 * x + b0
},
"svd" = {
y.hat <- svd(X)$u %*% t(svd(X)$u) %*% y
},
"pinv" = {
y.hat <- X %*% solve(t(X) %*% X) %*% t(X) %*% y
},
"lin.sys" = {
y.hat <- c(X %*% solve(t(X) %*% X, t(X) %*% y))
},
check = check_for_equal_coefs
)
mbm  ## lin.sys wins! (but cor close behind)
